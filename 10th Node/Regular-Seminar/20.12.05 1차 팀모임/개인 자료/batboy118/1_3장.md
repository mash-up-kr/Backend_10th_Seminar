<!-- TOC -->

- [1. 노드 시작하기](#1-노드-시작하기)
  - [1.1 핵심 개념 이해하기](#11-핵심-개념-이해하기)
    - [이벤트 기반](#이벤트-기반)
    - [논 블로킹 I/O](#논-블로킹-io)
    - [싱글 스레드](#싱글-스레드)
  - [1.2 서버로서의 노드](#12-서버로서의-노드)
  - [1.3 서버 외의 노드](#13-서버-외의-노드)
  - [1.4 개발 환경 설정하기](#14-개발-환경-설정하기)
- [2. 알아두어야 할 자바스크립트](#2-알아두어야-할-자바스크립트)
  - [2.1 ES2015+](#21-es2015)
    - [const, let](#const-let)
    - [템플릿 문자열](#템플릿-문자열)
    - [객체 리터럴](#객체-리터럴)
    - [화살표 함수](#화살표-함수)
    - [구조분해 할당](#구조분해-할당)
    - [클래스](#클래스)
    - [프로미스](#프로미스)
      - [async/await](#asyncawait)
  - [2.2 프런트엔드 자바스크립트](#22-프런트엔드-자바스크립트)
    - [AJAX (Asynchronuos Javascript And XML)](#ajax-asynchronuos-javascript-and-xml)
    - [FromData](#fromdata)
    - [encodeURIComponent, decodeURIComponent](#encodeuricomponent-decodeuricomponent)
    - [데이터 속성과 dataset](#데이터-속성과-dataset)
- [3. 노드 기능 알아보기](#3-노드-기능-알아보기)
  - [3.1 REPL 사용하기](#31-repl-사용하기)
  - [3.2 JS 파일 실행하기](#32-js-파일-실행하기)
  - [3.3 모듈로만들기](#33-모듈로만들기)
  - [3.4 노드 내장 객체 알아보기](#34-노드-내장-객체-알아보기)
  - [3.5 노드내장 모듈 사용하기](#35-노드내장-모듈-사용하기)
  - [3.6 파일 시스템 접근하기](#36-파일-시스템-접근하기)
  - [3.7 이벤트 이해하기](#37-이벤트-이해하기)
  - [3.8 예외 처리하기](#38-예외-처리하기)

<!-- /TOC -->

## 1. 노드 시작하기

### 1.1 핵심 개념 이해하기

`Node.js는 크롬 V8 Javascript 엔진으로 빌드된 Javascript 런타임`

- 노드는 여러곳에서 사용가능하지만, 서버에서 제일 많이 활용된다.

- 자바스크립트 프로그램을 컴퓨터에서 실행할 수 있게 해주는 것이 Node이다.
- 기존의 자바스크립트를 브라우저 외의 환경에서 실행하기 위한 시도가 있었지만, 너무 느려서 큰 호응을 받지못함 => 구글이 V8엔진을 사용하여 크롬을 만들었고, 속도가 크게 개선됨 => 라이언 달이 V8 기반의 노드 프로젝트를 시작하여 노드를 완성함
- Node는 V8엔진과 libuv 를 사용하며, 이는 C/C++로 구현되어 있음
  - libuv 라이브러리는 노드의 특성인 이벤트 기반, 논 블로킹 I/O 모델을 구현

#### 이벤트 기반

`이벤트가 발생할 때 미리 지정해둔 작업을 수행하는 방식`

- 이벤트 기반 시스템에서는 특정 이벤트가 발생할 때 무엇을 할지 미리 등록해야 함
  - 이벤트리스너에 콜백함수를 등록
- 노드도 이벤트 기반의 방식으로 동작
  - 이벤트가 발생하면 이벤트 리스너에 등록되어 있는 콜백함수를 호출
  - 처리할 이벤트가 없다면 다음 이벤트가 발생할 때 까지 대기
- `이벤트 루프` : 이벤트 기반 모델에서 사용되는 개념으로 여러 이벤트가 동시에 발생했을 대 어떤 순서로 콜백 함수를 호출할지를 이벤트 루프가 결정
- 비동기로 처리되는 경우에는 단순히 호출 스택으로 함수 호출의 순서를 결정하기 어려움
  - 이벤트 루프
    - 이벤트 발생 시 호출할 콜백 함수들을 관리
    - 호출된 콜백 함수의 실행 순서를 결정
    - 노드가 종료될 때까지 이벤트 처리를 위한 작업을 반복 (루프)
  - 백그라운드
    - setTimeout 같은 타이머나 이벤트 리스너들이 대기하는 곳
  - 태스크 큐
    - 이벤트 발생 후, 백그라운드에서는 `태스크 큐`로 타이머나 이벤트 리스너의 콜백 함수를 보냄
    - 정해진 순서대로 줄을 서 있으므로 콜백 큐라고도 부름
    - 콜백들은 보통 순서대로 줄을 서있지만, 특별한 경우 순서가 변경되기도 함

#### 논 블로킹 I/O

- 기본적으로 코드는 동시에 실행되지 않음

- 하지만, 외부 I/O 작업 같은 것은 동시에 처리가 가능함

- 시스템 접근(읽기, 쓰기, 생성 등), 네트워크 작업이 I/O의 예시

- 이렇게 외부 I/O 작업을 할 때 노드는 `논 블로킹` 방식을 제공

  `논 블로킹`: 이전 작업이 완료될 때까지 대기하지 않고 다음 작업을 수행함을 뜻함

  `블로킹`: 이전 작업이 끝나야만 다음 작업을 수행할 수 있음

- `setTimeout(callback, 0);`는 코드를 논블로킹으로 만들기 위해 사용하는 기법 중 하나

  - 주의) 기본적으로 브라우저에서는 4ms, 노드에서는 1ms의 지연시간이 있어 정확히 0초가 아니다.

- 논블로킹 != 동시

  - **동시성은 동시 처리가 가능한 작업을 논블로킹 처리해야얻을 수 있음** ???

#### 싱글 스레드

- 프로세스 : 운영체제에서 할당하는 작업의 단위

  - 메모리 자원 공유 x

- 스레드 : 프로세스 내에서 실행되는 흐름의 단위

  - 메모리 자원을 공유

- 노드는 싱글스레드?

  - 실제 노드 내부에는 여러개의 스레드가 있음
  - 단, 직접 코드로 제어가능한 스레드가 하나
  - 블로킹 작업에 부하가 많지 않다면, 싱글스레드만으로도 충분

- 스레드풀 & 워커스레드

  - 스레드풀 : 노드가 특정 동작을 수행할 때 노드 스스로 멀티 스레드를 사용 ex) 암호화
  - 워커 스레드 : 사용자가 직접 스레드를 다룰 수 있음. (보통 CPU intensive task)

- 싱글스레드 vs 멀티스레드

  - 싱글스레드 + 블로킹 : 매우 비효율

  - 싱글스레드 + 논블로킹 : 효율적

  - 멀티스레드 + 블로킹 : 노는 스레드 발생 & 비용이 많이 듦

  - 멀티스레드 + 논블로킹 : 성능은 좋지만 구현이 까다로움

    > 멀티스레드 방식대신 멀티 프로세스 방식을 사용

- I/O를 처리할 때 멀티 스레딩보다 멀티 프로세싱이 효율적이기 때문에 노드는 멀티 프로세싱을 많이 활용함 (클러스터링)

### 1.2 서버로서의 노드

- I/O를 많이 처리하는 서버의 경우 노드를 사용하는 것이 좋음
  - 논블로킹 방식으로 코드를 작성했을 경우 libuv 라이브러리를 사용하여, 논블로킹 방식으로 처리함
  - 많은 요청도 하나의 스레드로 감당할 수 있음
- CPU intensive한 작업은 좋지 않음

- 노드는 자체적으로 웹서버를 내장하고 있음

### 1.3 서버 외의 노드

- 웹 프레임워크 (앵귤러, 리액트, 뷰)
- 모바일 (리액트 네이티브)
- 데스크톱 (일렉트론)

### 1.4 개발 환경 설정하기

- LTS vs Current
  - LTS : 3년간 지원하는 버전
    - 짝수 버전만 LTS
  - Current : 최신 기능
    - 안정적이지 못할 수 있음

## 2. 알아두어야 할 자바스크립트

### 2.1 ES2015+

- ES2015(ES6) : 자바스크립트의 문법에 많은 변화가 있었음
- ES2020까지 나왔음

#### const, let

- var
  - 함수 스코프
- const, let
  - 블록 스코프

let과 const는 호이스팅이 될까? => 된다!

> https://medium.com/sjk5766/var-let-const-%ED%8A%B9%EC%A7%95-%EB%B0%8F-scope-335a078cec04

```js
var name = ‘seo’ // 전역변수
{
    console.log(name) //  name is not defined
    let name = ‘seo’ // 지역변수
}
```

#### 템플릿 문자열

```js
const a = 4
console.log(`a + 3 = ${a + 3}`)
```

#### 객체 리터럴

```js
const a = "abc"
const fn2 = function () {
  console.log("abc")
}
const obj = {
  fn() {
    console.log(123)
  },
  fn2,
  [a + "d"]: "good",
}

obj.fn() // 123
obj.fn2() // abc
console.log(obj.abcd) // good
```

#### 화살표 함수

- this 바인딩
  - 상위 스코프의 this를 그대로 물려받음

#### 구조분해 할당

#### 클래스

- 프로토타입 기반으로 만들어진 문법

#### 프로미스

- 콜백 지옥에서 해방되게 만들어 줌

- resolve/reject를 매개변수로 가지는 콜백 함수 사용

  - reslove => then
  - reject => catch

  ```js
  new Promise((res, rej) => {
      if(condition) res('success');
      else rej('fail')
  }).then((msg)=>{
      console.log(msg);
  }).catch((err)=>{
      console.err(err);
  }).
  ```

- then이나 catch를 체이닝으로 사용가능

  - then의 리턴값은 다음 then의 매개변수로 받음

- promise.all([p1,p2)].then(~).catch(~)

> `Promise.resolve(value)` 메서드는 주어진 값으로 이행하는 [`Promise.then`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) 객체를 반환합니다. 그 값이 프로미스인 경우, 해당 프로미스가 반환됩니다. 그 값이 thenable(예, [`"then" 메소드`](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Promise/then) 가 있음)인 경우, 반환된 프로미스는 그 thenable을 "따르며", 그 최종 상태를 취합니다. 그렇지 않으면 반환된 프로미스는 그 값으로 이행합니다. 이 함수는 프로미스형의 객체(무언가를 결정하는 프로미스를 결정하는 프로미스 등)의 중첩된 레이어를 단일 레이어로 펼칩니다.

##### async/await

- ES2017에서 추가

- 에러 처리는 try ~ catch로

- for문과 async/await을 같이 써서 프로미스를 순차적으로 실행

  ```js
  const p1 = Promise.resolve("성공1")
  const p2 = Promise.resolve("성공2")
  ;(async () => {
    for await (promise of [p1, p2]) {
      console.log(promise)
    }
  })()
  ```

### 2.2 프런트엔드 자바스크립트

#### AJAX (Asynchronuos Javascript And XML)

- 비동기적으로 서버에 요청을 할 경우 사용
- 브라우저에서 XMLHttpRequest 객체를 제공하지만, 노드에서는 사용할 수 없음
  - 더 쉽게 사용가능한 axios활용
- axios 내부에 Promise가 사용되어 then, catch 또는 asycn/await을 사용할 수 있음

#### FromData

- form 태그의 데이터를 동적으로 제어할 수 있음
- AJAX와 함께 사용하는 경우가 많음
- 키-밸류 형식으로 데이터를 추가하고 삭제할 수 있음

#### encodeURIComponent, decodeURIComponent

- URI에 한글 등 표준 URI에 해당하지 않는 문자가 들어갈 경우 표준형식으로 바꾸어 주는 기능
  - encodeURIComponent('노드') : 요청하는 쪽
  - decodeURIComponent('%EB%85%B8%EB%93%9C') : 받는쪽

#### 데이터 속성과 dataset

- html과 관련된 데이터를 html에 저장하는 방법
- `data-`로 시작
- 자바스크립트로 쉽게 접근이 가능함
- element의 dataset으로 접근가능

## 3. 노드 기능 알아보기

### 3.1 REPL 사용하기

- READ / EVAL / PRINT LOOP
- 실시간으로 자바스크립크 코드를 작성하면서 결과를 확인할 수 있음

### 3.2 JS 파일 실행하기

- `.js`파일을 만들어서 `node 파일명`으로 실행

### 3.3 모듈로만들기

- `require('모듈') / module.exports`
- ES2015 도입 후 자바스크립트도 자체 모듈 시스템 문법이 생김
  - import / export
  - 노드 9버전부터 사용가능
    - mjs확장자를 쓰거나, package.json 파일에 type:module 속성을 넣으면 됨

### 3.4 노드 내장 객체 알아보기

- global

  - 전역 객체 (브라우저의 window와 유사)
  - 전역객체이기 때문에 파일간의 간단한 데이터를 공유할 때 사용하기도 한다. (남용하지 않는 것이 좋다.)

- console

  - console.time(레이블)
    - console.timeEnd(레이블)과 대응되어 사이의 시간을 측정
  - console.table(배열)
    - 배열을 테이블 형식으로 표현
  - console.dir(객체, 옵션)
    - 객체의 depth, color 등을 설정가능 (기본depth2)
  - console.trace(레이블)
    - 에러가 어디서 발생했는지 추적

- 타이머

  - setTimeout(콜백 함수, 밀리초);
  - setInterval(콜백 함수, 밀리초);
  - setImmediate(콜백 함수);

  > 위 함수들은 모두 아이디를 반환

  - clearTimeout(아이디) : setTimeout취소
  - clearInterval(아이디) : setInterval취소
  - clearImmediate(아이디) : setImmediate취소

  > setTimeout(콜백, 0) vs setImmediate(콜백 함수)
  >
  > 특수한 경우 setImmediate가 먼저 실행(파일 시스템 접근, 네트워크 작업의 콜백 함수 안에서 타이머를 호출하는 경우)

- \_\_filename, \_\_dirname

  - 현재 파일 및 디렉토리 경로

- module, exports, require

  - 정리 필요

- process

  - 실행되고 있는 노드 프로세스에 대한 정보를 담고 있음
  - process.env
    - 환경변수
  - process.nextTick(콜백)
    - 다른 콜백함수보다 우선적으로 처리함
    - 마이크로태스크 큐를 사용함(프로미스도 이 큐를 사용)
      - 마이크로태스크 큐는 우선 호출되기 때문에 재귀를 과도하게 사용하면 태스크 큐의 콜백함수들이 실행되지 않을 수 있음
  - process.exit()
    - 프로세스를 종료
    - 시스템 반환값을 줄 수 있음
      - 0 정상종료
      - 1 비정상 종료

### 3.5 노드내장 모듈 사용하기

- os
  - OS, CPU, 메모리등의 정보를 담고 있음
- path
  - 폴더와 파일의 경로를 쉽게 조작 가능하도록 해주는 기능
    - 운영체제마다 경로구분자가 다른데, path를 사용하면 운영체제를 신경쓰지 않아도 됨
  - resolve와 join의 차이
    - `/`을 만나면 resolve는 절대경로 취급하여 앞의 경로를 무시, join은 상대경로 취급
- url
  - url을 쉽게 조작할 수 있도록 해주는 기능
  - url처리의 2가지 방식
    - WHATWG : node7에서 추가된 방식
    - url : 예전부터 사용되던 방식
  - new URL(주소) : WHATWG
  - url.parse(주소) : 과거 방식
- querystring
  - WHATWG방식의 url 대신 기존의 node url을 사용할 때 search(쿼리)부분을 사용하기 쉽게 객체로 만들어 주는 모듈
  - querystring.parse(url.parse(주소)) : 쿼리 객체를 만들어 준다.
  - querystring.stringfy(쿼리객체) : 쿼리 객체를 쿼리 스트링으로 만들어 준다.
- crypto
  - 다양한 방식의 암호화를 도와주는 모듈
  - 단방향 암호화
    - 비밀번호를 저장할 때 많이 사용
    - 복호화가 불가능 => 암호화 대신 해시라고도 함
    - crypto.createHash('sha512').update('password').digest('base64')
      - createHash(알고리즘) : 해시 알고리즘
      - update(패스워드) : 비밀번호를 넣음
      - digest : 해시 결과를 인코딩할 알고리즘을 넣음
        - base64, hex, latin1 등이 있고 base64가 가장짧아서 많이 사용함
    - 현재는 주로 pbkdf2, bcrypt, scrypt 알고리즘으로 비밀번호를 암호화함
      - pbkdf2 : salt라고 불리는 문자열을 붙인 후 해시 알고리즘을 반복해서 적용함
      - crypto.pbkdf2('password', salt, 100000, 64, 'sha512', (err, key) => {});
        - salt를 붙여서 10만번 암호화를 적용 (약1초)
      - cryto의 암호화는 스레드 풀을 이용하여 멀티스레딩으로 진행됨
      - pbkdf2 는 간단하지만 bcrypt나 scrypt보다는 취약하기 때문에 다른 방식을 이용하는 것이 좋음
  - 양방향 암호화
    - 복호화가 가능한 암호화 방식
    - 암호화에 사용된 키와 동일한 키를 사용해 복호화 가능
- util
  - 각종 편의 기능을 모아둔 모듈
  - util.deprecate() : 함수가 deprecated됨을 알려줌
  - util.promisfy () : 콜백 패턴의 함수를 프로미스 패턴으로 변경해줌
- worker_threads
  - 자식 스레드를 만들어서 관리할 수 있음
- child_process
  - 노드에서 다른 프로그램을 실행하고 싶거나 명령어를 수행하고 싶을 때 사용하는모듈
  - 현재 프로세스 이외의 다른 프로세스를 띄워서 명령을 수행
  - `exec(명령어)`는 셸에 명령어를 입력하고 결과를 리턴함
  - `spawn(명령어, [인수,])`는 새로운 프로세스를띄우면서 명령어를 실행함
- 그외
  - assert : 테스트
  - dns : DNS에서 ip주소
  - net : udp, tcp 통신
  - string_decoder : 버퍼 데이터를 문자열로바꾸는데 사용
  - tls : tls와 ssl에 관련된 작업
  - tty: 터미널과 관련된 작업
  - dgram: udp와 관련된 작업
  - v8 : v8엔진에 접근할 때 사용
  - vm: 가상머신에 접근할 때 사용

### 3.6 파일 시스템 접근하기

- fs모듈
  - 웹브라우저에서는 파일시스템에 대한 접근이 제한적
  - 노드에서는 fs모듈을 사용하여 자유롭게 접근 가능
- fs.readFile()의 결과물은 버퍼 형식으로 제공됨 => .toString()으로 문자열로변환할 수 있음
- `const fs = require('fs').promises;`로 불러오면 프로미스 기반의 fs 모듈 사용 가능
- 동기/비동기
  - 백그라운드 작업 완료 확인 여부
- 블로킹/논블로킹
  - 함수가 바로 return 되는지 여부
- 버퍼와 스트림
  - 파일 입출력에 사용되는 두 가지 방식
  - cf) 버퍼링, 스트리밍
  - 버퍼는 메모리에 저장되어 있는 데이터
  - 데이터가 크다면 버퍼의 사이즈도 커지게 된다. => 버퍼의 크기를 작게 하고, 여러번 데이터를 처리한다. => 스트림을 같이 사용
  - 입력 스트림과 출력 스트림을 pipe를 이용하여 연결할 수 있다.
    - 입력 스트림으로 들어온 값이 출력 스트림으로 써짐
  - 스레드풀
    - 비동기 메서드들은 백그라운드에서 실행되고, 실행된 후에는 다시 메인 스레드의 콜백 함수 또는 프로미스의 then이 처리 됨
    - fs도 비동기로 백그라운드에서 동시에 처리되는 건 스레드풀이 있기 때문이다.
    - 스레드 풀을 사용하는 대표적인 메서드
      - crypto, fs 등
    - 스레드풀은 개수가 정해져 있다.
      - 코어의 개수에 따라 기본 스레드의 수가 다름
      - 스레드의 개수 조절 가능

### 3.7 이벤트 이해하기

- 직접 이벤트를 만들 수 있음
- on : 이벤트 이름과 콜백함수를 연결함 (이벤트 리스닝)
- emit : 이벤트를 호출함
- addListener : on과 같음
- onece : 한 번만 실행되는 이벤트를 등록함 (여러번 emit해도 한번만 실행됨)
- removeAllListensers : 이벤트에 연결된 모든 이벤트 리스너를 제거함
- removeListener : 이벤트에 연결되어 있는 리스너를 하나 제거함(인자로 리스너를 넣어주어야 함)
- off : removeListener 와동일
- listenerCount : 이벤트와 연결된 리스너가 몇개인지 반환

### 3.8 예외 처리하기

- 노드는 스레드가 하나이기 때문에 하나의 스레드가 멈춘다는 것은 프로그램이 다운되는 것을 의미한다

- 메인 스레드가 에어로 인해 멈추지 않게 하는 것이 중요!

- 프로그램은 멈추지 않고 로그를 찍도록 만들면 좋다.

- try/catch

  ```js
  try {
    const a = 3 / 0
  } catch (err) {
    console.error(err)
  }
  ```

- 노드 자체에서 잡아주는 에러도 있다.(대부분의 노드 내장 모듈)

- 프로미스 에러는 catch하지 않아도 알아서 에러를 잡아준다.

- `uncaughtException`이벤트에 리스너를 등록하면, 예기치 못한 모든 에러에 대해 처리를 할 수 있다.

  - 하지만 예상치 못한 에러이기 때문에, 에러를 기록하고, 프로세스를 종료한 후 에러를 해결하는 것이 좋다.
